#! /usr/bin/python3
############################################################################
#
# MODULE: v.geolinkage
# AUTHOR: Felipe Troncoso <ftroncos@ing.uchile.cl>
# PURPOSE:
# COPYRIGHT:
#
#############################################################################

#%module
#% description: Make a linkage shapefile between a surface and groundwater model
#% keyword: vector
#% keyword: intersection
#% keyword: geometry
#% keyword: addons
#%end

#%option G_OPT_F_BIN_INPUT
#% key: linkage_in
#% type: string
#% required: yes
#% description: Path of input linkage shapefile
#% guisection: Linkage
#%end

#%flag
#% key: g
#% description: Get the input linkage shapefile generated by FloPy
#% guisection: Linkage
#% suppress_required: yes
#%end

#%option G_OPT_M_DIR
#% key: linkage_in_folder
#% type: string
#% required: no
#% description: Path of linkage folder to save the model grid shapefile generated by FloPy
#% guisection: Linkage
#%end

#%option G_OPT_F_BIN_INPUT
#% key: gw_model
#% type: string
#% required: no
#% description: Path of MODFLOW(2005) model file (.mfl or .nam usually)
#% guisection: Linkage
#%end

#%option
#% key: zrotation
#% type: double
#% required: no
#% multiple: no
#% description: Growndwater model rotation around z axis in degrees (counter-clockwise)
#% guisection: Linkage
#%end

#%option
#% key: coords_ll
#% type: double
#% required: no
#% multiple: no
#% key_desc: x,y
#% description: Real word coordinates for lower left corner
#% guisection: Linkage
#%end

#%option G_OPT_M_DIR
#% key: linkage_out_folder
#% type: string
#% required: yes
#% description: Path of folder to save final linkage
#% guisection: Linkage
#%end


#%option G_OPT_F_BIN_INPUT
#% key: node
#% type: string
#% required: yes
#% description: Path of node shapefile
#% guisection: Geometry
#%end

#%option G_OPT_F_BIN_INPUT
#% key: arc
#% type: string
#% required: yes
#% description: Path of arc shapefile
#% guisection: Geometry
#%end

#%option
#% key: epsg_code
#% description: EPSG Projection Code
#% required: yes
#% options: 1-1000000
#% answer: 32719
#% type: integer
#% guisection: Geometry
#% end


#%option G_OPT_F_BIN_INPUT
#% key: catchment
#% type: string
#% required: no
#% description: Path of catchment shapefile
#% guisection: Catchment
#%end

#%option
#% key: catchment_field
#% type: string
#% answer: Catchment
#% description: Field name in catchment map
#% guisection: Catchment
#% required: no
#%end


#%option G_OPT_F_BIN_INPUT
#% key: gw
#% type: string
#% required: no
#% description: Path of groundwater shapefile
#% guisection: Groundwater
#%end

#%option
#% key: gw_field
#% type: string
#% answer: GW
#% description: Field name in groundwater map
#% guisection: Groundwater
#% required: no
#%end


#%option G_OPT_M_DIR
#% key: ds_folder
#% type: string
#% required: no
#% description: Path of folder with demand site(s) shapefile(s) and wells textfile (.txt)
#% guisection: Demand Site
#%end

#%option
#% key: ds_field
#% type: string
#% answer: DS
#% description: Field name in demand site(s) map(s)
#% guisection: Demand Site
#% required: no
#%end

#%flag
#% key: C
#% description: Run geometry checks in the resulting linkage file.
#% guisection: GeoCheck
#% suppress_required: yes
#%end

#%option G_OPT_M_DIR
#% key: check_folder
#% type: string
#% required: no
#% description: Path of folder to where the results of the checks will be written.
#% guisection: GeoCheck
#%end

#%rules
#% requires_all: -g, gw_model, linkage_in_folder, linkage_out_folder, node, arc, epsg_code, coords_ll, zrotation
#% exclusive: -g, linkage_in
#%end


import os
import atexit
import ui

from grass_session import Session
from grass.exceptions import CalledModuleError
from grass.script.utils import try_rmdir
import grass.script as grass

from utils.Utils import UtilMisc
from AppKernel import AppKernel
from InterfaceApp import InterfaceApp
from utils.SummaryInfo import SummaryInfo


def print_summary(summary: SummaryInfo):
    prefix = summary.get_prefix()

    inputs = summary.print_input_params()
    lines = summary.print_process_line()
    errors = summary.print_errors()
    warnings = summary.print_warnings()

    lines_str = ''

    if inputs:
        msg_title = '[{}] INPUT PARAMETERS AND STATS'.format(prefix)
        grass.info("-" * (len(msg_title) + 2))
        grass.info(msg_title)
        grass.info("-" * (len(msg_title) + 2))
        grass.info(inputs)
        grass.info('\n')

    if lines:
        msg_title = '[{}] PROCESSING STATUS'.format(prefix)
        grass.info("-" * (len(msg_title) + 2))
        grass.info(msg_title)
        grass.info("-" * (len(msg_title) + 2))
        grass.info(lines)
        grass.info('\n')

    if warnings:
        msg_title = '[{}] WARNINGS'.format(prefix)
        grass.info("-" * (len(msg_title) + 2))
        grass.info(msg_title)
        grass.info("-" * (len(msg_title) + 2))
        grass.info(warnings)
        grass.info('\n')

    if errors:
        msg_title = '[{}] ERRORS'.format(prefix)
        grass.info("-" * (len(msg_title) + 2))
        grass.info(msg_title)
        grass.info("-" * (len(msg_title) + 2))
        grass.info(errors)
        grass.info('\n')


class GrassInterface(InterfaceApp):
    """
        It takes care of everything related to the input parameters, GRASS session generation used by the processing
        engine and displays execution results in the user's GRASS console.

        * Config file: ./config/config.json


        Attributes:
        ----------
        _config_opts : Dict[str, Dict | str]
            Class attribute that stores the input keywords and their meaning. This value is obtained from the
            configuration file.


        Methods:
        -------
        run(self)
            (Inherited from InterfaceApp) Executes the features processing engine with input parameters and options.

        check_args(self)
            (Inherited from InterfaceApp) Method not implemented because the parameters are collected automatically
            using the command 'grass.script.parse()'.

        print_catchment_summary(self)
            (Inherited from InterfaceApp) Prints the catchment processor execution results.

        print_gw_summary(self)
            (Inherited from InterfaceApp) Prints the groundwater processor execution results.

        print_ds_summary(self)
            (Inherited from InterfaceApp) Prints the demand site processor execution results.

        print_river_summary(self)
            (Inherited from InterfaceApp) Prints the river processor execution results.

        print_main_summary(self)
            (Inherited from InterfaceApp) Prints the application execution general results.

        print_input_summary(self)
            (Inherited from InterfaceApp) Prints the input parameters that the user entered.

        print_errors(self)
            (Inherited from InterfaceApp) Prints errors that happen when processing input parameters or some
            other error related to the user interface.


        Examples:
        --------
        >>> from AppKernel import AppKernel
        >>> from grass import script as gs

        >>> grass_vars = gs.parse_command("g.gisenv", flags="s")
        >>> gisdb, location, mapset = grass_vars["GISDBASE"], grass_vars["LOCATION"], grass_vars["MAPSET"]
        >>> app = AppKernel(gisdb=gisdb, location=location, mapset=mapset)
        >>> interface_app = GrassInterface(app=app, _gisdb=gisdb, _location=location, _mapset=mapset)

        >>> # get input parameters
        >>> options, flags = grass.parser()
        >>> linkage_in_file = options['linkage_in']
        >>> linkage_out_folder = options['linkage_out_folder']
        >>> node_file = options['node']
        >>> arc_file = options['arc']
        >>> catchment_file = options['catchment']
        >>> gw_file = options['gw']
        >>> ds_folder = options['ds_folder']
        >>> catchment_field = options['catchment_field']
        >>> gw_field = options['gw_field']
        >>> ds_field = options['ds_field']
        >>> epsg_in=options['epsg_code']

        >>> if flags['g']:  # make linkage grid using MODFLOW model and flopy
        >>>     interface_app.set_gw_model_coords_lower_left(coords_ll=options['coords_ll'])  # (x_ll, y_ll) in gw model
        >>>     interface_app.set_z_rotation(z_rotation=options['zrotation'])

        >>>     if interface_app.x_ll is not None and interface_app.y_ll is not None and interface_app.z_rotation is not None:
        >>>         app.set_origin(x_ll=interface_app.x_ll, y_ll=interface_app.y_ll, z_rotation=interface_app.z_rotation)

        >>>         interface_app.set_linkage_in_folder(linkage_in_folder=options['linkage_in_folder'])
        >>>         interface_app.set_gw_model(gw_model_file=options['gw_model'])

        >>>         # make grid with flopy
        >>>         interface_app.get_linkage_grid_by_model()
        >>>         linkage_in_file = interface_app.linkage_in_file

        >>> interface_app.set_feature_fields(catchment_field=catchment_field, gw_field=gw_field, ds_field=ds_field)
        >>> interface_app.set_required_paths(linkage_in_file=linkage_in_file, linkage_out_folder=linkage_out_folder,
        >>>                                      node_file=node_file, arc_file=arc_file)
        >>> interface_app.set_additional_paths(catchment_file=catchment_file, gw_file=gw_file, ds_folder=ds_folder)

        >>> if not interface_app.check_errors():
        >>>     app.set_epsg(epsg_code=epsg_in)
        >>>     interface_app.run()

        >>>     interface_app.print_input_summary()
        >>>     interface_app.print_main_summary()
        >>>     interface_app.print_catchment_summary()
        >>>     interface_app.print_gw_summary()
        >>>     interface_app.print_ds_summary()
        >>>     interface_app.print_river_summary()


        TODO:
        ----
            - Make sessions into processors
        """

    def __init__(self, app: AppKernel = None, _location: str = None, _mapset: str = None):
        super().__init__(app=app, _location=_location, _mapset=_mapset)

    def print_catchment_summary(self):
        summary = self.app.get_catchment_summary()
        print_summary(summary)

    def print_gw_summary(self):
        summary = self.app.get_gw_summary()
        print_summary(summary)

    def print_ds_summary(self):
        summary = self.app.get_ds_summary()
        print_summary(summary)

    def print_river_summary(self):
        summary = self.app.get_river_summary()
        print_summary(summary)

    def print_main_summary(self):
        summary = self.app.get_main_summary()
        print_summary(summary)

    def print_geo_summary(self):
        summary = self.app.get_geo_summary()
        print_summary(summary)

    def print_geo_check_summary(self):
        summary = self.app.get_geo_check_summary()
        print_summary(summary)

    def print_errors(self):
        if self.errors:
            for err in self.errors:
                grass.error(err)

    def print_input_summary(self):
        msg_title = 'INPUT PARAMETERS'
        grass.info("-" * (len(msg_title) + 2))
        grass.info(msg_title)
        grass.info("-" * (len(msg_title) + 2))

        grass.info('[LOCATION]: {}'.format(self.location))
        grass.info('[MAPSET]: {}'.format(self.mapset))
        grass.info('[EPSG CODE]: {}'.format(self.epsg_code))

        grass.info('[LINKAGE-IN FILE]: {}'.format(self.linkage_in_file))
        grass.info('[LINKAGE-OUT FOLDER]: {}'.format(self.linkage_out_folder))
        grass.info('[NODE FILE]: {}'.format(self.node_file))
        grass.info('[ARC FILE]: {}'.format(self.arc_file))

        grass.info('[CATCHMENT FILE]: {}'.format(self.catchment_file))
        grass.info('[CATCHMENT COLUMN]: {}'.format(self.catchment_field))

        grass.info('[GW FILE]: {}'.format(self.gw_file))
        grass.info('[GW COLUMN]: {}'.format(self.gw_field))

        grass.info('[DS FOLDER]: {}'.format(self.ds_folder))
        grass.info('[DS COLUMN]: {} \n'.format(self.ds_field))

        grass.info('[CHECK RESULT FOLDER]: {}'.format(self.geo_check_folder))

    def print_groundwater_model_info(self, gw_model):
        # get groundwater model info
        info = self.get_model_info(gw_model=gw_model)

        # print model info
        msg_title = 'INITIAL MODEL INFO:'
        grass.verbose(msg_title)
        grass.verbose('-' * len(msg_title))

        for concept in info:
            grass.verbose('[{}]: {}'.format(concept, info[concept]))

    def get_linkage_grid_by_model(self, linkage_file_name: str = 'linkage_in.shp'):
        msgs_it = self.make_linkage_grid(linkage_file_name=linkage_file_name)
        for msg in msgs_it:
            # TODO: We need to differentiate between error and info (Class SummaryProcess?)
            grass.info(msg)

    def check_args(self):
        pass

    def run(self):
        try:
            _err, _errors = self.app.run()
        except CalledModuleError as e:
            msg_errors = '\n'.join(e.msg.replace('\\n', '\n').split('\n'))
            grass.error(msg_errors)
            grass.fatal('EXECUTION FINISHED')


def cleanup(location: str):
    try_rmdir(location)


def main(location: str):
    ui.setup(verbose=True, quiet=False, color="never")  # the kernel app code use ui package

    app_sess = Session()
    app_sess.open(gisdb="/tmp", location=location, create_opts="EPSG:{}".format('32718'))
    options, flags = grass.parser()

    # init vars
    grass_vars = grass.parse_command("g.gisenv", flags="s")

    # init app and its interface
    gisdb = grass_vars["GISDBASE"]
    mapset = grass_vars["MAPSET"]
    app = AppKernel(gisdb=gisdb, location=location, mapset=mapset)
    interface_app = GrassInterface(app=app, _location=location, _mapset=mapset)

    # set the EPSG code
    interface_app.set_epsg_code(epsg_code=options['epsg_code'])

    # get or make the linkage-in shapefile
    if flags['g']:  # make linkage grid using MODFLOW model and flopy
        linkage_in_name_default = 'linkage_in.shp'

        linkage_in_folder = options['linkage_in_folder']
        gw_model_file = options['gw_model']

        interface_app.set_gw_model_coords_lower_left(coords_ll=options['coords_ll'])  # (x_ll, y_ll) in gw model
        interface_app.set_z_rotation(z_rotation=options['zrotation'])

        if interface_app.x_ll is not None and interface_app.y_ll is not None and interface_app.z_rotation is not None:
            app.set_origin(x_ll=interface_app.x_ll, y_ll=interface_app.y_ll, z_rotation=interface_app.z_rotation)

        if not (linkage_in_folder and gw_model_file):
            msg_error = 'Option [-g] requires of [gw_model], [linkage_in_folder]'
            grass.fatal(msg_error)

        # check if paths exist
        exist_files, exist_folders = UtilMisc.check_paths_exist(folders=[linkage_in_folder], files=[gw_model_file])
        if exist_folders[0][0] and exist_files[0][0]:
            interface_app.set_linkage_in_folder(linkage_in_folder=options['linkage_in_folder'])
            interface_app.set_gw_model(gw_model_file=options['gw_model'])

            linkage_in_file = os.path.join(linkage_in_folder, linkage_in_name_default)

            # make grid with flopy
            interface_app.get_linkage_grid_by_model(linkage_file_name=linkage_in_name_default)

            if not interface_app.check_errors():  # if not error:
                linkage_in_file = interface_app.linkage_in_file  # os.path.join(linkage_in_folder, linkage_in_name_default)
            else:
                # interface_app.print_errors()
                grass.fatal('Execution finished')
        elif not (exist_folders[0][0] or exist_files[0][0]):
            grass.error(exist_folders[0][1])
            grass.fatal(exist_files[0][1])
        elif not exist_folders[0][0]:
            grass.fatal(exist_folders[0][1])
        else:
            grass.fatal(exist_files[0][1])
    else:  # using an existing linkage-in shapefile
        linkage_in_file = options['linkage_in']

    # get input parameters
    linkage_out_folder = options['linkage_out_folder']
    node_file = options['node']
    arc_file = options['arc']
    catchment_file = options['catchment']
    gw_file = options['gw']
    ds_folder = options['ds_folder']
    catchment_field = options['catchment_field']
    gw_field = options['gw_field']
    ds_field = options['ds_field']
    geo_check_folder = options['check_folder'] #INTERFACE ADD

    interface_app.set_feature_fields(catchment_field=catchment_field, gw_field=gw_field,
                                     ds_field=ds_field)  # set fields

    # set paths
    interface_app.set_required_paths(linkage_in_file=linkage_in_file, linkage_out_folder=linkage_out_folder,
                                     node_file=node_file, arc_file=arc_file)
    interface_app.set_additional_paths(catchment_file=catchment_file, gw_file=gw_file, ds_folder=ds_folder, geo_check_folder= geo_check_folder) #INTERFACE ADD

    # run kernel code
    if not interface_app.check_errors():
        # app_sess = Session()
        # app_sess.open(gisdb="/tmp", location=interface_app.location, create_opts="EPSG:{}".format(interface_app.epsg_code))
        atexit.register(cleanup, location=location)
        interface_app.run()

        if flags['C']:
            interface_app.run_geo_checker()

        interface_app.print_input_summary()
        interface_app.print_main_summary()
        interface_app.print_geo_summary()
        interface_app.print_catchment_summary()
        interface_app.print_gw_summary()
        interface_app.print_ds_summary()
        interface_app.print_river_summary()

        if flags['C']:
            interface_app.print_geo_check_summary()

        app_sess.close()

    # else:
        # interface_app.print_errors()

    # write cmd history:
    # grass.vector_history(output)


if __name__ == "__main__":
    location =  UtilMisc.generate_word(length=5, prefix=InterfaceApp.config["COMMAND INTERFACE"]["location_prefix"])
    main(location=location)

