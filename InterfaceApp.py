
import json
import os
import pathlib
from abc import abstractmethod

from AppKernel import AppKernel


def open_default_config():
    current_folder = pathlib.Path(__file__).parent.absolute()
    with open(os.path.join(current_folder, 'config/config.json')) as json_data_file:
        config_data = json.load(json_data_file)

    return config_data


def check_in_grass_environment():
    import grass.script as gs

    try:
        grass_vars = gs.parse_command("g.gisenv", flags="s")
        in_grass_env = True
    except FileNotFoundError as e:
        in_grass_env = False
    return in_grass_env


class InterfaceApp:
    """
        Class with the structure to implement an user interface for the core processing.

        It processes input parameters, generates the GRASS session (grass_session library) that be used by the
        processing engine and displays the results of the execution.

        Currently two classes have been implemented that inherit from this class: CmdInterface and v.geolinkage.
        CmdInterface is designed to be run from a command line or terminal and v.geolinkage is implemented
        to be called from within GRASS, to use its UI.

        * Config File: ./config/config.json


        Attributes:
        ----------
        app : AppKernel
            Processing core instance.

        config : Dict[str, Dict]
            Class variable that allows access to application configuration constants.

        gisdb : str<path>
            gisdb GRASS session attribute.

        location : str
            location GRASS session attribute.

        mapset : str
            mapset GRASS session attribute (example: PERMANENT).

        linkage_in_file : str<path>
            Path to ESRI shapefile (.SHP) with initial groundwater grid.

        linkage_out_folder : str<path>
            Folder path to store the final linkage file.

        node_file : str<path>
            Path to ESRI shapefile (.SHP) with nodes map.

        arc_file : str<path>
            Path to ESRI shapefile (.SHP) with arcs map.

        catchment_file : str<path>
            Path to ESRI shapefile (.SHP) with catchments map.

        gw_file : str<path>
            Path to ESRI shapefile (.SHP) with groundwaters map.

        ds_folder : str<path>
            Folder path with ESRI shapefile files (.SHP) of demand sites area maps.
            In this path you should also leave the plain text file (.txt) with the names of the wells.

        epsg_code : int<code>
            EPSG code.

        catchment_field : str
            Column in input shapefile metadata that identifies catchment names. (default: CATCHMENT)

        gw_field : str
            Column in input shapefile metadata that identifies groundwater names. (default: GW)

        ds_field : str
            Column in input shapefile metadata that identifies demand site names. (default: DS)

        make_grid : bool
            Defines if to get the initial grid from groundwater model or from input shapefile.

        gw_model_file : str<path>
            File path of the groundwater model (MODFLOW 2000/2005, generally .NAM or .mdf file).

        linkage_in_folder : str<path>
            Folder path where to store the ESRI shapefile (.SHP) extracted from groundwater model.
            (Case when 'make_grid' input parameter is True).

        z_rotation : float
            Rotation angle of the groundwater model.

        x_ll : float
            X-axis coordinate for groundwater model lower left corner.

        y_ll : float
            Y-axis coordinate for groundwater model lower left corner.

        errors : List[str]
             List with user input processing errors.


        Methods:
        -------
        run(self)
            Run the processing engine with user input parameters and options.
            (Abstract method to be implemented in the child classes).

        check_args(self)
            Configures and parses necessary arguments for processing engine execution.
            (Abstract method to be implemented in the child classes).

        get_model_info(cls, gw_model)
            Gets general information about the groundwater MODFLOW model.
            The 'gw_model' parameter is an groundwater MODFLOW model instance, generated by the FloPy library.

        print_groundwater_model_info(self, gw_model)
            Prints general information of the groundwater model (MODFLOW model only).

        make_linkage_grid(self, linkage_file_name: str)
            Generates a vector map with initial grid from the groundwater model (using the FloPy library).
            The 'linkage_file_name' parameter corresponds to ESRI shapefile path where to store the grid file.

        set_required_paths(self, linkage_in_file: str, linkage_out_folder: str, node_file: str, arc_file: str)
            Sets necessary files to run the processing engine: node, arc and initial groundwater grid files.
            The 'linkage_in_file' parameter contains the groundwater grid file path.
            The 'linkage_out_folder' parameter contains the folder path where to export shapefile with initial grid.
            The 'node_file' and 'arc_file' parameters correspond to node and arc shapefiles paths, respectively.

        set_additional_paths(self, catchment_file: str, gw_file: str, ds_folder: str)
            Sets additional files to run the processor engine.
            Additional files correspond to catchment file, groundwater file, and demand sites files.
            The 'catchment_file' contains the catchment file path (.SHP only).
            The 'gw_file' contains the groundwater file path (.SHP only).
            The 'ds_folder' parameter contains folder path where to find demand site shapefiles (with areas)
            and the well file (.TXT only).

        set_feature_fields(self, catchment_field: str, gw_field: str, ds_field: str)
            Sets the columns in shapefiles metadata from which to read feature names to be processed.
            The 'catchment_field' and 'gw_field' parameters contain the columns for catchment and groundwater maps.
            The 'ds_field' parameter contains the column name for maps with demand sites areas.

        set_gw_model(self, gw_model_file: str)
            Sets groundwater model file path from the parameter 'gw_model_file'.
            If 'make_grid' attribute is True, the initial grid is extracted from the groundwater model (MODFLOW).

        set_epsg_code(self, epsg_code: str)
            Stores EPSG code GRASS session attribute and validates that it is a integer number.

        set_gisdb(self, gisdb: str)
            Sets 'gisdb' GRASS session attribute.

        set_location(self, _location: str)
            Sets 'location' GRASS session attribute.

        set_mapset(self, _mapset: str)
            Sets 'mapset' GRASS session attribute.

        set_gw_model_coords_lower_left(self, coords_ll)
            Stores x_ll and y_ll coords (low left corner) of the groundwater model and validates that they
            are not null and floating numbers.

        set_z_rotation(self, z_rotation)
            Stores rotation angle of the groundwater model and validates that it is a floating number.

        print_catchment_summary(self)
            Prints the catchment processor execution results.
            (Abstract method to be implemented in the child classes).

        print_gw_summary(self)
            Prints the groundwater processor execution results.
            (Abstract method to be implemented in the child classes).

        print_ds_summary(self)
            Prints the demand site processor execution results.
            (Abstract method to be implemented in the child classes).

        print_river_summary(self)
            Prints the river processor execution results.
            (Abstract method to be implemented in the child classes).

        print_main_summary(self)
            Prints the application execution general results.
            (Abstract method to be implemented in the child classes).

        print_input_summary(self)
            Prints the input parameters that the user entered.
            (Abstract method to be implemented in the child classes).

        print_errors(self)
            Prints errors that happen when processing input parameters or some
            other error related to the user interface.
            (Abstract method to be implemented in the child classes).

        """

    config = open_default_config()

    def __init__(self, app: AppKernel = None, _gisdb: str = None, _location: str = None, _mapset: str = None):
        if app:
            self.app = app
        else:
            self.app = AppKernel(gisdb=_gisdb, location=_location, mapset=_mapset)

        self.gisdb = _gisdb
        self.location = _location
        self.mapset = _mapset

        self.linkage_in_file = None
        self.linkage_out_folder = None
        self.node_file = None
        self.arc_file = None
        self.catchment_file = None
        self.gw_file = None
        self.ds_folder = None
        self.geo_check_folder = None
        self.epsg_code = None
        self.catchment_field = None
        self.gw_field = None
        self.ds_field = None

        # with option [-g]
        self.make_grid = False
        self.gw_model_file = None
        self.linkage_in_folder = None
        self.z_rotation = None
        self.x_ll = None  # real world model coords (lower left)
        self.y_ll = None  # real world model coords (lower left)

        self.geo_checker = None

        self.errors = []


    @abstractmethod
    def print_catchment_summary(self):
        pass

    @abstractmethod
    def print_gw_summary(self):
        pass

    @abstractmethod
    def print_ds_summary(self):
        pass

    @abstractmethod
    def print_river_summary(self):
        pass

    @abstractmethod
    def print_main_summary(self):
        pass

    @abstractmethod
    def print_geo_summary(self):
        pass

    @abstractmethod
    def print_geo_check_summary(self):
        pass

    def set_gw_model(self, gw_model_file: str):
        self.make_grid = True

        self.gw_model_file = gw_model_file

    def set_linkage_in_folder(self, linkage_in_folder):
        self.make_grid = True

        self.linkage_in_folder = linkage_in_folder

    def set_z_rotation(self, z_rotation):
        self.make_grid = True

        # get z-rotation gw model
        try:
            self.z_rotation = float(z_rotation.strip())
        except ValueError as e:
            self.errors.append('Groundwater model rotation [{}] is not valid. Set to [0.0]'.format(z_rotation))
            self.z_rotation = 0.0
        except AttributeError as e:
            self.errors.append('Groundwater model rotation is empty. Set to [0.0]'.format(z_rotation))
            self.z_rotation = 0.0

    def run_geo_checker(self):
        if self.geo_check_folder:
            self.app.run_geo_checker(result_path=self.geo_check_folder)

    def set_gw_model_coords_lower_left(self, coords_ll):
        self.make_grid = True

        if coords_ll is None:
            self.errors.append('Lower left corner coordinates are empty'.format(coords_ll))
            coords_ll = [None, None]
        else:
            lower_left_corner = [c.strip() for c in coords_ll.split(',')]
            try:
                if len(lower_left_corner) > 1:
                    coords_ll = [float(lower_left_corner[0]), float(lower_left_corner[1])]
                else:
                    self.errors.append(
                        'Lower left corner coordinates [({})] are not valid.'.format(coords_ll))
                    coords_ll = [None, None]
            except ValueError as e:
                self.errors.append(
                    'Lower left corner coordinates [({})] are not valid.'.format(coords_ll))
                coords_ll = [None, None]

        self.x_ll = coords_ll[0]
        self.y_ll = coords_ll[1]

    def check_errors(self):
        _err = False
        if self.errors:
            _err = True

        return _err

    @abstractmethod
    def print_errors(self):
        pass

    def set_gisdb(self, gisdb: str):
        self.gisdb = gisdb

    def set_location(self, _location: str):
        self.location = _location

    def set_mapset(self, _mapset: str):
        self.mapset = _mapset

    def set_required_paths(self, linkage_in_file: str, linkage_out_folder: str, node_file: str, arc_file: str):
        if linkage_in_file and linkage_out_folder and arc_file and node_file:
            # set in app
            self.app.set_linkage_in_file(file_path=linkage_in_file)
            self.app.set_linkage_out_file(folder_path=linkage_out_folder)
            self.app.set_geo_file_path(file_path=arc_file, is_arc=True)
            self.app.set_geo_file_path(file_path=node_file, is_node=True)

            _errors = self.app.check_input_path_errors(required=True, additional=False)
            if _errors:
                for _err in _errors:
                    self.errors.append(_err)
            else:
                # set in properties
                self.linkage_in_file = linkage_in_file
                self.linkage_out_folder = linkage_out_folder
                self.node_file = node_file
                self.arc_file = arc_file
        else:
            self.errors.append('linkage_in file is required') if not linkage_in_file else None
            self.errors.append('linkage_out folder is required') if not linkage_out_folder else None
            self.errors.append('node file is required') if not node_file else None
            self.errors.append('arc file is required') if not arc_file else None

    def set_additional_paths(self, catchment_file: str, gw_file: str, ds_folder: str, geo_check_folder: str):
        # set in app
        # self.app.set_catchment_file(file_path=catchment_file, is_main_file=True) if catchment_file else None
        # self.app.set_groundwater_file(file_path=gw_file, is_main_file=True) if gw_file else None
        f_catchment_type = self.app.catchment_processor.get_feature_type()
        f_gw_type = self.app.groundwater_processor.get_feature_type()
        self.app.set_demand_site_folder(folder_path=ds_folder)
        self.app.set_geo_check_results_folder(folder_path=geo_check_folder)
        self.app.set_feature_file_path(feature_type=f_catchment_type, file_path=catchment_file, is_main_file=True)
        self.app.set_feature_file_path(feature_type=f_gw_type, file_path=gw_file, is_main_file=True)

        _errors = self.app.check_input_path_errors(required=False, additional=True)
        if _errors:
            for _err in _errors:
                self.errors.append(_err)
        else:
            # set in properties
            self.catchment_file = catchment_file
            self.gw_file = gw_file
            self.ds_folder = ds_folder
            self.geo_check_folder = geo_check_folder

    def set_epsg_code(self, epsg_code: str):
        try:
            self.epsg_code = int(epsg_code)
        except ValueError as e:
            self.errors.append('EPSG code [{}] is wrong'.format(epsg_code))
            self.epsg_code = None
        except TypeError as e:
            self.errors.append('EPSG code is empty'.format(epsg_code))
            self.epsg_code = None

    def set_feature_fields(self, catchment_field: str, gw_field: str, ds_field: str):
        # set in app
        self.app.set_config_field(catchment_field=catchment_field, groundwater_field=gw_field,
                                  demand_site_field=ds_field)

        # set in properties
        self.catchment_field = catchment_field
        self.gw_field = gw_field
        self.ds_field = ds_field

    @abstractmethod
    def print_input_summary(self):
        pass

    @classmethod
    def get_model_info(cls, gw_model):
        # flopy change SpatialReference for Grid (StructuredGrid) and now always
        # use LOWER LEFT (it used [ml.sr.origin_loc] bedore)
        print_info = {
            'ORIGIN REFERENCE': 'LOWER LEFT CORNER (ll)',
            'PROJECTION': gw_model.modelgrid.proj4,
            'LOWER LEFT CORNER': '({}, {})'.format(str(gw_model.modelgrid.xoffset), str(gw_model.modelgrid.yoffset)),
            'ROTATION': str(gw_model.modelgrid.angrot) + " DEGREES",
            'ROWS': gw_model.modelgrid.nrow,
            'COLS': gw_model.modelgrid.ncol,
            'LAYERS': gw_model.modelgrid.nlay,
            'GRID TYPE': gw_model.modelgrid.grid_type,
        }
        print_info['GRID TYPE'] += ' X-REGULAR' if gw_model.modelgrid.is_regular_x else ' X-NOT-REGULAR'
        print_info['GRID TYPE'] += ' Y-REGULAR' if gw_model.modelgrid.is_regular_y else ' Y-NOT-REGULAR'

        return print_info

    @abstractmethod
    def print_groundwater_model_info(self, gw_model):
        pass

    def make_linkage_grid(self, linkage_file_name: str):
        import flopy

        gw_model_file = self.gw_model_file
        linkage_folder = self.linkage_in_folder
        epsg_code = self.epsg_code

        msg_str = 'Reading groundwater model [{}]'.format(gw_model_file)
        yield msg_str

        model_path = os.path.dirname(gw_model_file)
        model_file = os.path.basename(gw_model_file)

        linkage_file_path = os.path.join(linkage_folder, linkage_file_name)

        try:
            ml = flopy.modflow.Modflow.load(model_file, model_ws=model_path, exe_name='mf2005', verbose=False, check=True)

            # get groundwater model info
            self.print_groundwater_model_info(gw_model=ml)

            # update structured grid with x_ll_real, y_ll_real, rot_degrees_cw (origin param)
            if self.x_ll is not None and self.y_ll is not None:
                if self.z_rotation is not None:
                    ml.modelgrid.set_coord_info(xoff=self.x_ll, yoff=self.y_ll, angrot=self.z_rotation,
                                                epsg=self.epsg_code, merge_coord_info=True)
                else:
                    ml.modelgrid.set_coord_info(xoff=self.x_ll, yoff=self.y_ll, angrot=0.0,
                                                epsg=self.epsg_code, merge_coord_info=True)
                # save to shapefile
                # ml.dis.export(linkage_file_path, epsg=int(epsg_code))
                # from flopy.utils.crs import get_authority_crs
                # crs_utm = get_authority_crs(f"EPSG:{epsg_code}")

                ml.modelgrid.write_shapefile(filename=linkage_file_path, epsg=self.epsg_code)

                # check if it exists new file
                if not os.path.isfile(linkage_file_path):
                    msg_error = 'Input linkage shapefile could not be created: [{}]'.format(linkage_file_path)
                    self.errors.append(msg_error)

                    yield msg_error
                else:
                    self.linkage_in_file = linkage_file_path

                    msg_info = 'Input linkage shapefile was created successfully: [{}]'.format(linkage_file_path)
                    yield msg_info
            else:
                msg_error = 'Input linkage shapefile could not be created: [{}]'.format(linkage_file_path)
                self.errors.append(msg_error)

                # yield msg_error
        except OSError as e:
            ml = None

    @abstractmethod
    def check_args(self):
        print()
        pass

    @abstractmethod
    def run(self):
        pass


